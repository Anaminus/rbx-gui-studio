--[[Status
Displays the current status of the program.

Messages added to the Status are added to a stack. The message on the top of the stack is displayed.
Messages consist of multiple strings, which are ordered using a numerical index.
The visiblity of these "message parts" may be toggled, so that only certain parts of the message are displayed.

msg = Status:Add('Example',{'herp', 'derp'})  -> ""
msg:Show(1)                                   -> "herp"
msg:Show(2)                                   -> "herp derp"
msg:Hide(1)                                   -> "derp"

API:
	Status.StatusFrame              The GUI that displays the status message.
	Status:Add(ref,parts)           Adds a new Message to the top of the stack.
	                                `parts` is a table of strings that make up the message.
	                                Returns the new message.
	Status:Remove(ref)              Removes the Message referenced by `ref`.

	Message:GetString()             Returns the string generated by this message.
	Message:Show(...)               Shows one or more message parts.
	Message:Hide(...)               Hides one or more message parts.
]]

do
	local StatusFrame = Create'TextLabel'{
		Name = "Status Label";
		BackgroundTransparency = 1;
		Text = "";
		TextColor3 = InternalSettings.GuiColor.Text;
		FontSize = 'Size9';
		TextWrapped = true;
		TextXAlignment = 'Left';
		TextYAlignment = 'Top';
	}

	local MessageLookup = {}
	local MessageStack = {}


	local function updateDisplay()
		if #MessageStack > 0 then
			StatusFrame.Text = MessageLookup[MessageStack[#MessageStack]]:GetString()
		else
			StatusFrame.Text = ""
		end
	end

	local createMessage do
		local mtMessage = {
			__index = {
				Destroy = function(self)
				--	setmetatable(self,nil)
				end;
				GetString = function(self)
					local messageSet = self.MessageSet
					local visibleSet = self.VisibleSet
					local sorted = {}
					for i,v in pairs(messageSet) do
						if visibleSet[i] and type(i) == 'number' then
							sorted[#sorted+1] = i
						end
					end
					table.sort(sorted)
					local message = {}
					for _,i in pairs(sorted) do
						message[#message+1] = tostring(messageSet[i])
					end
					return table.concat(message," ")
				end;
				Show = function(self,...)
					local visibleSet = self.VisibleSet
					local args = {...}
					for i = 1,#args do
						visibleSet[args[i]] = true
					end
					updateDisplay()
				end;
				Hide = function(self,...)
					local visibleSet = self.VisibleSet
					local args = {...}
					for i = 1,#args do
						visibleSet[args[i]] = nil
					end
					updateDisplay()
				end;
			};
		}

		function createMessage(data)
			return setmetatable({ MessageSet = data or {}, VisibleSet = {} }, mtMessage)
		end
	end

	Status = {
		StatusFrame = StatusFrame;
	}

	function Status:Add(ref,data)
		-- if the reference doesn't exist, add it to the stack
		if not MessageLookup[ref] then
			table.insert(MessageStack,ref)
			MessageLookup[ref] = createMessage(data)
		end
		updateDisplay()
		return MessageLookup[ref]
	end

	function Status:Remove(ref)
		local message = MessageLookup[ref]
		if message ~= nil then
			for i = #MessageStack,1,-1 do
				if MessageStack[i] == ref then
					table.remove(MessageStack,i)
					break
				end
			end
			MessageLookup[ref] = nil
			message:Destroy()
			updateDisplay()
		end
	end
end
